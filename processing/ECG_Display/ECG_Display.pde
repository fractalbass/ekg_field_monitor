// A sample program for displaying ecg waveforms generated by the
// olimex ecg arduino shield.  
// https://www.olimex.com/Products/Duino/Shields/SHIELD-EKG-EMG/
//
// This program is probaby a bit more complicated that it needs to be to simply display
// a waveform.  However, the goal was to create a processing (v3) sketch that would work
// with the sample arduino code provided by Olimex.  That code was intended to work with
// a windows only application that appears to be no longer supported, and was "close-source"
//
// Data from the arduino with the olimex shield comes in with the structure as follows:
// (Taken from the arduino program...)
//  uint8_t  sync0;    // = 0xa5
//  uint8_t  sync1;    // = 0x5a
//  uint8_t  version;  // = 2 (packet version)
//  uint8_t  count;    // packet counter. Increases by 1 each packet.
//  uint16_t  data[6];  // 10-bit sample (= 0 - 1023) in big endian (Motorola) format.
//  uint8_t  switches;  // State of PD5 to PD2, in bits 3 to 0.
//
//  The values above are unsigned ints.  The hard part of this program is getting the data
//  out of the uint16 array and casting it to an actual int value.
import processing.serial.*;

Serial myPort;  // The serial port
    
    byte[] bytes = new byte[15];    // Used to hold the last 15 of 17 bytes in the stream.
    int[] yOffset = {150, 300, 450};  // Used for the 2x3 waveform grid display   
    int[] xOffset = {0,500};        // Used for the 2x3 waveform grid display.
    float[] y1old = {0,0,0,0,0,0};  // used to draw solid lines in graphing.
    float[] y2old = {0,0,0,0,0,0};  // used to draw solid lines in graphing.
    int x=0;                        // The x coordinate of the waveforms.
    color c1=#FF0000;               // Colors used for display
    color c2=#00FF00;               // Colors used for dispaly

    
void setup() {
  // List all the available serial ports
  printArray(Serial.list());
  // Open the port you are using at the rate you want:
  myPort = new Serial(this, Serial.list()[5], 57600);  //Make sure this baud matches the arduino.
  size(1000,450);
  noSmooth();
  background(0);
}

void draw() {
  
  while (myPort.available() > 0) {
    int c1=myPort.read();
    int c2=myPort.read();
    if ((c1==0xa5) && (c2==0x5a)) {  // Check to see if we have the sync bytes.
      myPort.readBytes(bytes);  //  Read the rest of the data from the stream.
      x++;                      //  Increment the x axis for graphing.
      stroke(0);                //  Set the color to solid black
      line(x,0,x,450);          //  Clear the graph in the first column at this x coordinate.
      line(x+500,0,x+500,450);  //  Similarly erase the points in the second column.
      if (x>500) {x=0;}         //  If we have gone past the end of the column width, start over.
      
      for(int c = 0; c < 6; c++) {                      //  Iterate the the 6 channels.
        int highByte = bytes[2+(c*2)] & 0xFF;           //  Read the high byte of the current channel
        int lowByte = bytes[2+(c*2)+1] & 0xFF;          //  Read the low byte of the current channel
        if(highByte < 0) {highByte = highByte + 256;}   //  Convert the data from an int to an unsigned int.
        if(lowByte < 0) {lowByte = lowByte + 256;}      //  Convert the data from an int to an unsigned int.
        
        int y = lowByte + (256*highByte);             //  Combine the low and high bytes to get the original value.
        float yM = map(y, 0, 1023, 0, 150);           //  Adjust the data from a scale of 0-1023 to 0-150 for graphing.
        float y1 = yOffset[c%3]-(yM);                 //  Adjust the graph Y value to the current row of the grid.
        int xo = xOffset[c%2]+x;                      //  Adjust the graph X value to the current column of the grid.
        
        if (xo==0) {                 //  If we are starting the x axis over at 0, don't draw a line from the previous point.
          stroke(c1);
          point(xo,y1);
          y1old[c]=y1;               //  "Remember" the previous point so that we can use it to draw a line next time.
        } else {
         stroke(c1);                 //  "If we're not starting over, draw a line from the previous point to the new one
         line(xo,y1,xo-1,y1old[c]);
         stroke(c2);
         y1old[c]=y1;                //  Again, remember the new point.
        }
      }
    }
  }
}


  